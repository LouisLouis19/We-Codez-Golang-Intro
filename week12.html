<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Programming - Sorting Algorithms</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Introduction to Programming</h1>
        <h2>Week 12: Basics of Sorting Algorithms</h2>
    </header>

    <div class="container">
        <aside class="sidebar">
            <nav>
                <ul>
                    <li><a href="index.html">Week 1 - Programming Basics</a></li>
                    <li><a href="week2.html">Week 2 - Python Control Flow</a></li>
                    <li><a href="week3.html">Week 3 - Python Control Flow (Part 2)</a></li>
                    <li><a href="week4.html">Week 4 - Python Functions </a></li>
                    <li><a href="week5.html">Week 5 - Python Functions (Part 2)</a></li>
                    <li><a href="week6.html">Week 6 - Python Functions (Part 3)</a></li>
                    <li><a href="week7.html">Week 7 - Data Structures</a></li>
                    <li><a href="week8.html">Week 8 - Data Structures (Part 2)</a></li>
                    <li><a href="week9.html">Week 9 - Data Structures (Part 3)</a></li>
                    <li><a href="week10.html">Week 10 - Project</a></li>
                    <li><a href="week11.html">Week 11 - Algorithms</a></li>
                    <li><a href="week12.html" class="active">Week 12 Overview</a></li>
                    <li><a href="week13.html">Week 13 - Debugging and Problem Solving</a></li>
                    <li><a href="conclusion.html">Conclusion</a></li>
                    <li><a href="project.html">Project</a></li>
                </ul>
            </nav>
        </aside>
        <main>
            <section class="overview">
                <h2>Overview</h2>
                <p>This week, we will explore basic sorting algorithms. Sorting algorithms are fundamental in computer science and are used to arrange data in a specific order. We will cover Bubble Sort, Selection Sort, and Insertion Sort, and discuss their time complexities and implementations.</p>
            </section>

            <section class="introduction-to-algorithms">
                <h2>Introduction to Algorithms</h2>
                <p>An algorithm is a step-by-step procedure for performing a task or solving a problem. In computer science, algorithms are crucial for tasks like sorting data, searching, and performing calculations.</p>
                
                <h3>Basic Concepts</h3>
                <ul>
                    <li><b>Input:</b> The data provided to the algorithm.</li>
                    <li><b>Output:</b> The result produced by the algorithm.</li>
                    <li><b>Efficiency:</b> How well the algorithm performs with respect to time and space.</li>
                    <li><b>Time Complexity:</b> A measure of how the running time of an algorithm increases with the size of the input.</li>
                </ul>
            </section>

            <section class="basic-sorting-algorithms">
                <h2>Basic Sorting Algorithms</h2>

                <h3>Bubble Sort</h3>
                <p>Bubble Sort repeatedly compares and swaps adjacent elements until the list is sorted. It is known for its simplicity but is inefficient for large lists.</p>
                <pre class="code-block"># Bubble Sort Implementation in Python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Example usage
example_list = [64, 34, 25, 12, 22, 11, 90]
sorted_list = bubble_sort(example_list)
print(sorted_list)  # Outputs [11, 12, 22, 25, 34, 64, 90]</pre>
                <p><b>Time Complexity:</b> O(n^2)</p>

                <h3>Selection Sort</h3>
                <p>Selection Sort works by repeatedly finding the smallest (or largest) element from the unsorted part and moving it to the beginning. It improves on Bubble Sort but still has O(n^2) complexity.</p>
                <pre class="code-block"># Selection Sort Implementation in Python
def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# Example usage
example_list = [64, 34, 25, 12, 22, 11, 90]
sorted_list = selection_sort(example_list)
print(sorted_list)  # Outputs [11, 12, 22, 25, 34, 64, 90]</pre>
                <p><b>Time Complexity:</b> O(n^2)</p>

                <h3>Insertion Sort</h3>
                <p>Insertion Sort builds the final sorted array one item at a time by inserting each new item into its proper position. It is efficient for small lists or nearly sorted lists.</p>
                <pre class="code-block"># Insertion Sort Implementation in Python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Example usage
example_list = [64, 34, 25, 12, 22, 11, 90]
sorted_list = insertion_sort(example_list)
print(sorted_list)  # Outputs [11, 12, 22, 25, 34, 64, 90]</pre>
                <p><b>Time Complexity:</b> O(n^2)</p>
            </section>

            <section class="algorithmic-analysis">
                <h2>Algorithmic Analysis</h2>
                <h3>Big O Notation</h3>
                <p>Big O Notation describes the time complexity of an algorithm in terms of its input size. It provides an upper bound on the growth rate of the algorithm's runtime.</p>
                <ul>
                    <li><b>O(1):</b> Constant time complexity. The runtime does not change with the input size.</li>
                    <li><b>O(n):</b> Linear time complexity. The runtime increases linearly with the input size.</li>
                    <li><b>O(n^2):</b> Quadratic time complexity. The runtime grows quadratically with the input size.</li>
                    <li><b>O(log n):</b> Logarithmic time complexity. The runtime grows logarithmically with the input size.</li>
                </ul>

                <h3>Best, Average, and Worst Case Analysis</h3>
                <p>Algorithms can have different time complexities for different cases:</p>
                <ul>
                    <li><b>Best Case:</b> The scenario where the algorithm performs the minimum number of operations.</li>
                    <li><b>Average Case:</b> The expected performance of the algorithm over a range of inputs.</li>
                    <li><b>Worst Case:</b> The scenario where the algorithm performs the maximum number of operations.</li>
                </ul>
            </section>

            <section class="practice">
                <h2>Practice</h2>
                <h3>1. Implement Bubble Sort</h3>
                <p>Implement the Bubble Sort algorithm and test it with different lists. Try to sort lists of varying sizes and measure the performance.</p>
                <details>
                    <summary>Solution</summary>
                    <div>
                        <pre class="code-block">def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Example usage
example_list = [64, 34, 25, 12, 22, 11, 90]
sorted_list = bubble_sort(example_list)
print(sorted_list)  # Outputs [11, 12, 22, 25, 34, 64, 90]</pre>
                    </div>
                </details>

                <h3>2. Implement Selection Sort</h3>
                <p>Implement the Selection Sort algorithm and test it with different lists. Compare its performance with Bubble Sort.</p>
                <details>
                    <summary>Solution</summary>
                    <div>
                        <pre class="code-block">def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i+1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr

# Example usage
example_list = [64, 34, 25, 12, 22, 11, 90]
sorted_list = selection_sort(example_list)
print(sorted_list)  # Outputs [11, 12, 22, 25, 34, 64, 90]</pre>
                    </div>
                </details>

                <h3>3. Implement Insertion Sort</h3>
                <p>Implement the Insertion Sort algorithm and test it with different lists. Compare its performance with Bubble Sort and Selection Sort.</p>
                <details>
                    <summary>Solution</summary>
                    <div>
                        <pre class="code-block">def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i-1
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

# Example usage
example_list = [64, 34, 25, 12, 22, 11, 90]
sorted_list = insertion_sort(example_list)
print(sorted_list)  # Outputs [11, 12, 22, 25, 34, 64, 90]</pre>
                    </div>
                </details>

                <h3>4. Compare Sorting Algorithms</h3>
                <p>Write a script to compare the performance of Bubble Sort, Selection Sort, and Insertion Sort on lists of different sizes. Measure and report the time taken for each algorithm.</p>
                <details>
                    <summary>Solution</summary>
                    <div>
                        <pre class="code-block">import time

def measure_time(sort_function, arr):
    start_time = time.time()
    sort_function(arr)
    end_time = time.time()
    return end_time - start_time

list_sizes = [10, 100, 1000]
for size in list_sizes:
    test_list = list(range(size, 0, -1))  # List in descending order
    print(f"List size: {size}")
    print("Bubble Sort:", measure_time(bubble_sort, test_list.copy()))
    print("Selection Sort:", measure_time(selection_sort, test_list.copy()))
    print("Insertion Sort:", measure_time(insertion_sort, test_list.copy()))</pre>
                    </div>
                </details>

                <h3>5. Analyze Time Complexity</h3>
                <p>For each sorting algorithm, analyze the best, average, and worst case time complexities. Discuss how the input size affects the performance of each algorithm.</p>
                <details>
                    <summary>Discussion</summary>
                    <div>
                        <p>Bubble Sort, Selection Sort, and Insertion Sort all have a time complexity of O(n^2) in the worst case. They perform similarly with large inputs, but Insertion Sort can perform better on nearly sorted data. The best-case scenario for Insertion Sort is O(n) if the list is already sorted. Selection Sort always performs O(n^2) operations.</p>
                    </div>
                </details>
            </section>
        </main>
    </div>
    <footer>
        <p>&copy; 2024 We Codez</p>
    </footer>
</body>
</html>
