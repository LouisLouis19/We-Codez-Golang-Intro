<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Introduction to Programming - Searching Algorithms</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <header>
      <h1>Introduction to Programming</h1>
      <h2>Week 11: Basics of Searching Algorithms</h2>
    </header>

    <div class="container">
      <aside class="sidebar">
        <nav>
          <ul>
            <li><a href="index.html" class="active">Programming Basics</a></li>
            <li><a href="week2.html">Python Control Flow</a></li>
            <li><a href="while_loops.html">Python Control Flow (Part 2)</a></li>
            <li><a href="functions_1.html">Python Functions </a></li>
            <li><a href="week5.html">Python Functions (Part 2)</a></li>
            <li><a href="week6.html">Python Functions (Part 3)</a></li>
            <li><a href="week7.html">Data Structures</a></li>
            <li><a href="week8.html">Data Structures (Part 2)</a></li>
            <li><a href="week9.html">Data Structures (Part 3)</a></li>
            <li><a href="week10.html">Project</a></li>
            <li><a href="week11.html">Algorithms</a></li>
            <li><a href="week12.html">Algorithms (Part 2)</a></li>
            <li><a href="week13.html">Debugging and Problem Solving</a></li>
            <li><a href="conclusion.html">Conclusion</a></li>
            <li><a href="project.html">Project</a></li>
          </ul>
        </nav>
      </aside>
      <main>
        <section class="overview">
          <h2>Overview</h2>
          <p>
            This week, we will dive into basic searching algorithms. Searching
            algorithms are used to find a specific element in a collection of
            data. We will cover Linear Search and Binary Search, and discuss
            their time complexities and implementations.
          </p>
        </section>

        <section class="introduction-to-algorithms">
          <h2>Introduction to Algorithms</h2>
          <p>
            An algorithm is a step-by-step procedure for performing a task or
            solving a problem. Searching algorithms are fundamental for tasks
            like finding items in a list, database querying, etc.
          </p>

          <h3>Basic Concepts</h3>
          <ul>
            <li><b>Input:</b> The data on which the algorithm operates.</li>
            <li>
              <b>Output:</b> The result or position of the element being
              searched for.
            </li>
            <li>
              <b>Efficiency:</b> How well the algorithm performs in terms of
              time and space.
            </li>
            <li>
              <b>Time Complexity:</b> Measures how the runtime of an algorithm
              grows with the input size.
            </li>
          </ul>
        </section>

        <section class="basic-searching-algorithms">
          <h2>Basic Searching Algorithms</h2>

          <h3>Linear Search</h3>
          <p>
            Linear Search checks each element one by one until the desired
            element is found or the end of the list is reached. It is simple but
            inefficient for large lists.
          </p>
          <pre class="code-block">
# Linear Search Implementation in Python
def linear_search(arr, target):
    for index, value in enumerate(arr):
        if value == target:
            return index
    return -1  # Target not found

# Example usage
example_list = [10, 20, 30, 40, 50]
target = 30
result = linear_search(example_list, target)
print("Element found at index:", result)  # Outputs: Element found at index: 2</pre
          >
          <p><b>Time Complexity:</b> O(n)</p>

          <h3>Binary Search</h3>
          <p>
            Binary Search works by dividing the search interval in half. It
            requires the data to be sorted. The algorithm repeatedly narrows
            down the search range until the target element is found or the range
            is empty.
          </p>
          <pre class="code-block">
# Binary Search Implementation in Python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # Target not found

# Example usage
example_list = [10, 20, 30, 40, 50]
target = 30
result = binary_search(example_list, target)
print("Element found at index:", result)  # Outputs: Element found at index: 2</pre
          >
          <p><b>Time Complexity:</b> O(log n)</p>
        </section>

        <section class="algorithmic-analysis">
          <h2>Algorithmic Analysis</h2>
          <h3>Big O Notation</h3>
          <p>
            Big O Notation describes the time complexity of an algorithm,
            indicating its growth rate in relation to the input size.
          </p>
          <ul>
            <li>
              <b>O(1):</b> Constant time complexity. The runtime remains
              constant regardless of input size.
            </li>
            <li>
              <b>O(n):</b> Linear time complexity. The runtime increases
              linearly with the input size.
            </li>
            <li>
              <b>O(n^2):</b> Quadratic time complexity. The runtime grows
              quadratically with the input size.
            </li>
            <li>
              <b>O(log n):</b> Logarithmic time complexity. The runtime grows
              logarithmically with the input size.
            </li>
          </ul>

          <h3>Best, Average, and Worst Case Analysis</h3>
          <p>
            Each algorithm can have different time complexities depending on the
            scenario:
          </p>
          <ul>
            <li>
              <b>Best Case:</b> The optimal scenario where the algorithm
              performs the fewest operations.
            </li>
            <li>
              <b>Average Case:</b> The expected performance of the algorithm
              over a typical range of inputs.
            </li>
            <li>
              <b>Worst Case:</b> The scenario where the algorithm performs the
              maximum number of operations.
            </li>
          </ul>
        </section>

        <section class="practice">
          <h2>Practice</h2>
          <h3>1. Implement Linear Search</h3>
          <p>
            Implement the Linear Search algorithm and test it with various
            lists. Experiment with different target values and list sizes.
          </p>
          <details>
            <summary>Solution</summary>
            <div>
              <pre class="code-block">
def linear_search(arr, target):
    for index, value in enumerate(arr):
        if value == target:
            return index
    return -1  # Target not found

# Example usage
example_list = [10, 20, 30, 40, 50]
target = 30
result = linear_search(example_list, target)
print("Element found at index:", result)  # Outputs: Element found at index: 2</pre
              >
            </div>
          </details>

          <h3>2. Implement Binary Search</h3>
          <p>
            Implement the Binary Search algorithm and test it with sorted lists.
            Compare its performance with Linear Search on large datasets.
          </p>
          <details>
            <summary>Solution</summary>
            <div>
              <pre class="code-block">
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1  # Target not found

# Example usage
example_list = [10, 20, 30, 40, 50]
target = 30
result = binary_search(example_list, target)
print("Element found at index:", result)  # Outputs: Element found at index: 2</pre
              >
            </div>
          </details>

          <h3>3. Compare Searching Algorithms</h3>
          <p>
            Write a script to compare the performance of Linear Search and
            Binary Search on lists of different sizes. Measure and report the
            time taken for each algorithm.
          </p>
          <details>
            <summary>Solution</summary>
            <div>
              <pre class="code-block">
import time

def measure_time(search_function, arr, target):
    start_time = time.time()
    search_function(arr, target)
    end_time = time.time()
    return end_time - start_time

list_sizes = [10, 100, 1000, 10000]
for size in list_sizes:
    test_list = list(range(size))  # Sorted list
    target = size // 2
    print(f"List size: {size}")
    print("Linear Search:", measure_time(linear_search, test_list, target))
    print("Binary Search:", measure_time(binary_search, test_list, target))</pre
              >
            </div>
          </details>

          <h3>4. Analyze Search Algorithm Performance</h3>
          <p>
            Discuss the performance of Linear Search and Binary Search for
            various data sizes. Include observations on how the time complexity
            impacts performance.
          </p>
          <details>
            <summary>Discussion</summary>
            <div>
              <p>
                Linear Search's time complexity is O(n), meaning its performance
                degrades linearly with larger datasets. In contrast, Binary
                Search has a time complexity of O(log n), making it
                significantly faster on large sorted datasets. However, Binary
                Search requires sorted data, which may involve additional
                overhead.
              </p>
            </div>
          </details>
        </section>
      </main>
    </div>
    <footer>
      <p>&copy; 2024 We Codez</p>
    </footer>
  </body>
</html>
